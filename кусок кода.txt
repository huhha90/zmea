def change_nickname_menu(self):
        input_active = True
        current_nickname = self.settings["profile"]["nickname"]
        max_nickname_length = 15
        input_box_rect = pygame.Rect(self.width // 2 - 150, self.height // 2 - 30, 300, 60)
        back_button_rect = pygame.Rect(self.width // 2 - 100, self.height - 100, 200, 50)

        while input_active:
            self.screen.fill(BG_COLOR)

            title = self.font.render(self.get_text("change_nickname"), True, TEXT_COLOR)
            title_rect = title.get_rect(center=(self.width // 2, 150))
            self.screen.blit(title, title_rect)

            mouse_pos = pygame.mouse.get_pos()
            pygame.draw.rect(self.screen, BUTTON_COLOR, input_box_rect, border_radius=10)

            nickname_surface = self.font.render(current_nickname, True, TEXT_COLOR)
            nickname_rect = nickname_surface.get_rect(midleft=(input_box_rect.left + 15, input_box_rect.centery))
            self.screen.blit(nickname_surface, nickname_rect)

            back_color = HOVER_COLOR if back_button_rect.collidepoint(mouse_pos) else BUTTON_COLOR
            pygame.draw.rect(self.screen, back_color, back_button_rect, border_radius=10)
            back_label = self.font.render(self.get_text("back"), True, TEXT_COLOR)
            back_label_rect = back_label.get_rect(center=back_button_rect.center)
            self.screen.blit(back_label, back_label_rect)

            pygame.display.flip()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.exit_game()
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        input_active = False
                        self.show_menu()
                        return
                    elif event.key == pygame.K_RETURN:
                        if current_nickname.strip():
                            self.settings["profile"]["nickname"] = current_nickname.strip()
                            save_json_file(SETTINGS_FILE, self.settings)
                            input_active = False
                            self.show_menu()
                            return
                        else:
                            print("Нікнейм не може бути порожнім!")
                            current_nickname = self.settings["profile"]["nickname"]
                    elif event.key == pygame.K_BACKSPACE:
                        current_nickname = current_nickname[:-1]
                    else:
                        if len(current_nickname) < max_nickname_length and (event.unicode.isalnum() or event.unicode in (' ', '_', '-')):
                            current_nickname += event.unicode
                elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    if back_button_rect.collidepoint(event.pos):
                        self.play_sound("click")
                        input_active = False
                        self.show_menu()
                        return

            self.clock.tick(self.settings["graphics"].get("fps", 60))


    def run_game(self, training=False, start_level=None):
        self.game_running = True; self.training_mode = training; self.paused = False; self.score = 0
        self.next_level_available = False; self.new_level_unlocked_message = ""; self._start_next_level_on_exit = False
        self.current_level = None # Скидаємо за замовчуванням

        game_fps = self.settings["gameplay"]["default_speed"] # Типова швидкість

        if self.training_mode:
            self.play_music("training"); self.start_snake(); print("Запуск тренувального режиму.")
        elif start_level is not None: # Якщо запускаємо конкретний рівень
            if self.levels and 0 <= start_level < len(self.levels):
                self.current_level = start_level; level_data = self.levels[self.current_level]
                self.play_music("level", level_data); self.start_snake_with_level(level_data)
                game_fps = level_data.get("speed", game_fps); print(f"Запуск рівня {self.current_level + 1}.")
            else: # Помилка індексу рівня
                print(f"Помилка: Невірний індекс рівня {start_level}. Запуск типової гри."); self.play_music("game"); self.start_snake(); self.current_level = None
        else: # "Грати" з меню (start_level is None)
            print("Запуск типової гри (без рівнів)."); self.play_music("game"); self.start_snake(); self.current_level = None # Явно вказуємо, що рівня немає

        # Основний ігровий цикл
        while self.game_running:
            self.handle_events();
            if not self.game_running: break # Вихід, якщо гра була закрита в handle_events

            # Перевірка, чи потрібно зупинити рух змійки після завершення рівня
            level_complete_pause_active = self.new_level_unlocked_message and self.next_level_available

            # Оновлення стану гри тільки якщо не на паузі і не в стані "рівень пройдено"
            if not self.paused and not level_complete_pause_active:
                self.update_snake();
                if not self.game_running: break # Перевірка після update_snake (можливе зіткнення зі стіною)
                self.check_collisions();
                if not self.game_running: break # Перевірка після check_collisions (зіткнення з собою)
                self.check_level_completion() # Перевіряємо завершення рівня

            # Малювання завжди відбувається, щоб показати повідомлення, паузу тощо
            self.draw_game_state()
            self.clock.tick(game_fps) # Використовуємо швидкість гри

        # --- Кінець ігрового циклу ---

        # Збереження рахунку, якщо гра завершилась не через вихід в меню з паузи
        if not self.paused and self.score > 0:
             # Передаємо індекс рівня для збереження
             self.save_score_to_leaderboard(self.score, self.training_mode, self.current_level)

        # Перехід на наступний рівень або показ екрану завершення
        if self._start_next_level_on_exit:
            self._start_next_level_on_exit = False; next_level_index = self.current_level + 1
            if self.levels and 0 <= next_level_index < len(self.levels):
                 print(f"Перехід на рівень {next_level_index + 1}")
                 self.run_game_with_level(next_level_index)
            else:
                 print("Наступного рівня немає, повернення в меню.")
                 self.show_menu()
        elif not self.paused: # Показуємо Game Over тільки якщо гра не була просто закрита/вийдена в меню
            self.show_game_over_screen(self.score)
        # Якщо self.paused is True, значить гра завершилась виходом в меню з паузи,
        # show_menu() вже було викликано в handle_events

def show_settings_menu(self):
        self.play_sound("click")
        menu_active = True
        self.active_settings_submenu = None
        button_keys = ["settings_audio", "settings_graphics", "settings_skins", "settings_language", "back"]
        actions = {
            "settings_audio": self.show_audio_settings,
            "settings_graphics": self.show_graphics_settings,
            "settings_skins": self.show_skin_settings,
            "settings_language": self.show_language_settings,
            "back": self.show_menu
        }
        button_rect_data = self._create_button_rects(button_keys)
        while menu_active:
            if self.active_settings_submenu:
                submenu_func = self.active_settings_submenu
                self.active_settings_submenu = None
                submenu_func()
                if not self.running:
                    menu_active = False
                continue

            self.screen.fill(BG_COLOR)
            title = self.font.render(self.get_text("settings"), True, TEXT_COLOR)
            title_rect = title.get_rect(center=(self.width // 2, button_rect_data[0][0].top - 60))
            self.screen.blit(title, title_rect)
            mouse_pos = pygame.mouse.get_pos()
            self._draw_buttons(button_rect_data, mouse_pos)
            pygame.display.flip()

            for event in pygame.event.get():
                if event.type == pygame.QUIT: self.exit_game()
                elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                    save_json_file(SETTINGS_FILE, self.settings)
                    menu_active = False
                    self.show_menu()
                    return
                elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    for rect, key in button_rect_data:
                        if rect.collidepoint(mouse_pos):
                            self.play_sound("click")
                            if key == "back":
                                save_json_file(SETTINGS_FILE, self.settings)
                                menu_active = False
                                actions[key]()
                                return
                            else:
                                self.active_settings_submenu = actions[key]
                            break
            self.clock.tick(self.settings["graphics"].get("fps", 60))